#include "../include/tree.hpp"
#include <iostream>
#include <queue>

using namespace std;

// ??????????? ??????
tree::tree() {
    root = nullptr;
    node_cnt = 0;
}

// ?????????? ??????
tree::~tree() {
    // ??????????? ???????? ???? ?????
    bypass_reset(root);
}

// ????? ???? ?? ID (????? ? ??????)
node* tree::find_node(node* current, int ID) {
    if (!current) return nullptr;

    queue<node*> q;
    q.push(current);

    while (!q.empty()) {
        node* front = q.front();
        q.pop();

        if (front->ID == ID) {
            return front;
        }

        // ????????? ???? ????? ? siblings
        node* c = front->child;
        while (c) {
            q.push(c);
            c = c->sibling;
        }
    }

    return nullptr;
}

// ????????, ???? ?? ???? ? ??????
bool tree::is_in_tree(int ID) {
    return find_node(root, ID) != nullptr;
}

// ??????? ?????? ????
bool tree::insert(int ID) {
    if (is_in_tree(ID)) {
        return false;
    }

    node* newNode = new node;
    newNode->ID = ID;

    if (!root) {
        root = newNode;
        node_cnt = 1;
        return true;
    }

    // ??????? ? ??????
    queue<node*> q;
    q.push(root);

    while (!q.empty()) {
        node* front = q.front();
        q.pop();

        if (!front->child) {
            front->child = newNode;
            node_cnt++;
            return true;
        } else {
            node* c = front->child;
            while (c->sibling) {
                c = c->sibling;
            }
            c->sibling = newNode;
            node_cnt++;
            return true;
        }
    }

    delete newNode;
    return false;
}

// ????????? ???? ?? ID
node* tree::get(int ID) {
    return find_node(root, ID);
}

// ????????? ????? ??????
node* tree::get_root() {
    return root;
}

// ????? ???????? ????
int tree::parent_id(int child_id) {
    if (!root || !is_in_tree(child_id)) {
        return -1;
    }

    queue<node*> q;
    q.push(root);

    while (!q.empty()) {
        node* front = q.front();
        q.pop();

        node* c = front->child;
        while (c) {
            if (c->ID == child_id) {
                return front->ID;
            }
            q.push(c);
            c = c->sibling;
        }
    }

    return -1;
}

// ???????????? ??????
void tree::draw_tree() {
    draw_subtree(root, 0);
}

// ??????????? ???????????? ?????????
void tree::draw_subtree(node* current, int level) {
    if (!current) return;

    // ?????? siblings
    draw_subtree(current->sibling, level);

    // ??????? ??? ??????
    for (int i = 0; i < level; ++i) {
        cout << "   ";
    }

    // ??????? ID ???? ? ??? ??????
    cout << current->ID << (current->available ? "(+)" : "(-)") << "\n";

    // ?????? ?????
    draw_subtree(current->child, level + 1);
}

// ???????? ??????????? ????
bool tree::is_available(int ID) {
    node* n = get(ID);
    if (!n) return false;
    return n->available;
}

// ????????? ??????????? ????
void tree::change_availability(int ID, bool status) {
    node* n = get(ID);
    if (n) {
        n->available = status;
    }
}

// ????? ??????????? ???? ????? ? ?????????
void tree::bypass_reset(node* current) {
    if (!current) return;
    current->available = false;
    bypass_reset(current->sibling);
    bypass_reset(current->child);
}

// ???? ???? ??????????? ?????
void tree::bypass(node* current, vector<int>& unavailable) {
    if (!current) return;
    if (!current->available) {
        unavailable.push_back(current->ID);
    }
    bypass(current->sibling, unavailable);
    bypass(current->child, unavailable);
}

// ?????????? ????? ? ??????
int tree::cnt() {
    return node_cnt;
}